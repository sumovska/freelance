"""
Parser for the OMF2 Object Module Format

This module is able to parse files in the format OMF2 format
as generated by the Keil toolchain.

This is documented here:

http://cltd-confluence.cochlear.com/download/attachments/68943999/OMF251V25.pdf?version=1&modificationDate=1281938160000

There are two main parts to this module, the low-level parser, and the
high-level object file inspector object.

OMF2 files are arranged as a list of records, each with a different
record type. The low-level parser extracts these individual records
from the input data. As the format of each individual record is
different, a separate class is defined for each record type. These
classes define an unpack() method.

The low-level parser is available using the parse() function. This
is a generator function, yield each individual record in the OMF2
formatted data.

The low-level parser is used by the high-level object file
representation Omf2File. This class provides an easy way of
accessing logical parts of the object file.

Currently, only access to public and debug symbol is provided
through this class. It is expected that in the future this
class will be extended to provide convenient access to other
data.

It is expected that most users of this module will use the high-level
Omf2File class, rather than directly using the low-level parsing.

"""
import ctypes
__author__ = "Ben Leslie"
__change__ = "$Change: 232759 $"
__revision__ = "$Revision: #4 $"
__date__ = "$DateTime: 2014/05/21 17:56:59 $"
__copyright__ = "Company Confidential. Copyright (c) Cochlear Ltd 2010"

import struct

#
# Part 1: Low-level parser
#

#
# Helper function for dealing with type (TI) and memory class (MCI)
# index data
#
typeindex = {
    0x0: "untyped",
    0x1: "bit",
    0x2: "signed char",
    0x3: "unsigned char",
    0x4: "signed int",
    0x5: "unsigned int",
    0x6: "signed long",
    0x7: "unsigned long",
    0x8: "float",
    0x9: "double",
    0xa: "label (near)",
    0xb: "void",
    0xc: "float (be)",
    0xd: "double (be)",
    0xe: "untyped byte",
    0xf: "untyped word",
    0x10: "untyped dword",
    0x11: "label (far)",
}


def showti(ti):
    if ti < 0x80:
        return typeindex.get(ti, "Unknown Basic Type")
    else:
        return "TI-idx %s" % (ti)

memindex = {
    0x1: "XDATA",
    0x2: "DATA",
    0x3: "IDATA",
    0x4: "BIT",
    0x5: "CODE",
    0x6: "ECODE",
    0x7: "EDATA",
    0x8: "HDATA",
    0x9: "PDATA",
    0xa: "EBIT",
    0xb: "CONST",
    0xc: "HCONST",
    0xd: "NCONST",
    0xe: "NUMBER",
    0xf: "SROM",
    0x10: "XCONST",
    0x11: "SDATA"
}


def getmci(code):
    for idx, value in memindex.items():
        if value == code:
            break
    else:
        raise Exception("Uknown memory type: %s" % code)
    return idx


def showmci(mci):
    if mci < 0x80:
        return memindex.get(mci, "Unknown Basic MCI %d" % mci)
    else:
        return "MCI-idx %s" % (mci - 0x80)

codemem = [getmci("CODE"), getmci("ECODE")]
datamem = [getmci("XDATA"), getmci("DATA"), getmci("IDATA"), getmci("EDATA"), getmci("HDATA"), getmci("PDATA"), getmci("SDATA")]
constmem = [getmci("CONST"), getmci("NCONST"), getmci("HCONST"), getmci("XCONST")]


class Record(object):
    """Base OMF2 record class. To be sub-classed for each record type.
    Each record type should implement the unpack method."""

    def __init__(self, rectype, data):
        self.rectype = rectype
        self.data = data
        self.unpack()

    def unpack(self):
        pass


class Headr(Record):
    def unpack(self):
        strlen = struct.unpack("<B", self.data[0])[0]
        self.name = struct.unpack("<%sp" % (strlen + 1), self.data)[0]


class Theadr(Headr):
    def __str__(self):
        return "<Theadr %s>" % self.name


class Lheadr(Headr):
    def __str__(self):
        return "<Theadr %s>" % self.name


class Aheadr(Headr):
    def __str__(self):
        return "<Aheadr %s>" % self.name


class Modend(Record):
    def __str__(self):
        return "<Modend>"


class Modinf(Record):
    def unpack(self):
        modinf = struct.unpack("<7B", self.data)
        self.model = modinf[0]
        self.model51 = modinf[1]
        self.mode = modinf[2]
        self.flag = modinf[3]
        self.vendor = modinf[4]
        self.rbanks = modinf[5]
        self.oem_vers = modinf[6]

    def __str__(self):
        return "<Modinf model=%s mode=%s>" % (self.model, self.mode)


class Ovldef(Record):
    def unpack(self):
        fmt = "<HBIBIB"
        si, _, start, _, length, procnamelen = struct.unpack_from(fmt, self.data, 0)
        self.si = si
        self.start = start
        self.length = length
        name = struct.unpack_from("%ss" % procnamelen, self.data, struct.calcsize(fmt))[0]
        self.name = name

    def __str__(self):
        return "<Ovldef %s si=%s start=%s length=%s>" % (self.name, self.si, self.start, self.length)


class Locsym(Record):
    def unpack(self):
        fmt = "<BHB"
        ofs = 0
        self.fields = struct.unpack_from(fmt, self.data, ofs)
        _, self.ti, strlen = self.fields
        ofs += struct.calcsize(fmt)
        fmt = "<%ss" % strlen
        self.name = struct.unpack_from(fmt, self.data, ofs)[0]

    def __str__(self):
        return "<Locsym %s , %s>" % (self.name, showti(self.ti))


class Comment(Record):
    def unpack(self):
        fmt = "<BB"
        ofs = 0
        self.comtyp, strlen = struct.unpack_from(fmt, self.data, ofs)
        ofs += struct.calcsize(fmt)
        fmt = "<%ss" % strlen
        self.cominfo = struct.unpack_from(fmt, self.data, ofs)

    def __str__(self):
        return "<Comment type:%s %s" % (self.comtyp, self.cominfo)


class Segdef(Record):
    def unpack(self):
        fmt = "<BBBIBIHB"
        fields = struct.unpack_from(fmt, self.data, 0)
        strlen = fields[7]
        self.alntyp = fields[0]
        self.reltyp = fields[1]
        self.addr = fields[3]
        self.seglen = fields[5]
        self.mci = fields[6]
        if memindex[self.mci] == "BIT":
            self.bitAddr = self.addr
            self.bitSeglen = self.seglen
            self.addr = self.bitAddr / 8
            self.seglen = (self.bitSeglen - 1) / 8 + 1
        self.name = struct.unpack_from("%ss" % strlen, self.data, struct.calcsize(fmt))[0]

    def __str__(self):
        return "<Segdef %-35s addr:0x%08x length:%5s align:%s rel:%s mci:%s>" % (self.name, self.addr, self.seglen, self.alntyp, self.reltyp, showmci(self.mci))


class Blkdef(Record):
    def unpack(self):
        fmt = "<HHHBIB"
        fields = struct.unpack_from(fmt, self.data, 0)
        strlen = fields[5]
        self.fi = fields[0]
        self.ti = fields[1]
        self.blockbase = fields[2]
        self.blockoffs = fields[4]
        self.name = struct.unpack_from("%ss" % strlen, self.data, struct.calcsize(fmt))[0]

    def __str__(self):
        return "<Blkdef %s fi:%s ti:%s blockbase:%s blockoffs:0x%x>" % (self.name, self.fi, self.ti, self.blockbase, self.blockoffs)


class Blkend(Record):
    def unpack(self):
        fmt = "<BI"
        fields = struct.unpack_from(fmt, self.data, 0)
        self.blocklength = fields[1]

    def __str__(self):
        return "<Blkend %s>" % (self.blocklength)


#
# This defines the PubDef/DebDef sub-records. PubDef and
# DebSym record containi a list of individual PubDef/DebDef
# sub-records. These are essentially the same type so
# the GendefRec forms a common sub-class to do all the heavy
# lifting.
#
class GendefRec(object):
    def __init__(self, name, base, offs, mci, ti):
        self.name = name
        self.base = base
        self.offs = offs
        self.ti = ti
        self.mci = mci

    def __repr__(self):
        return "<%s %s ti:%s mci:%s>" % (self.__class__.__name__, self.name, showti(self.ti), showmci(self.mci))


class PubdefRec(GendefRec):
    pass


class DebdefRec(GendefRec):
    pass


class Gendef(Record):
    def unpack(self):
        self.records = []
        ofs = 0
        while ofs < len(self.data):
            fmt = "<HBIHHB"
            self.fields = struct.unpack_from(fmt, self.data, ofs)
            procnamelen = self.fields[5]
            ofs += struct.calcsize(fmt)
            name = struct.unpack_from("%ss" % procnamelen, self.data, ofs)[0]
            ofs += procnamelen
            rec = self.childclass(name, self.fields[0], self.fields[2], self.fields[3], self.fields[4])
            self.records.append(rec)

    def __str__(self):
        return "<%s %s>" % (self.name,
                            "\n ".join([str(x) for x in self.records]))


class Pubdef(Gendef):
    name = "Pubdef"
    childclass = PubdefRec


class Debsym(Gendef):
    name = "Debsym"
    childclass = DebdefRec


#
# Sub-record of the Linnum
#
class LinDef(object):
    def __init__(self, linnum, linoff):
        self.linnum = linnum
        self.linoff = linoff

    def __str__(self):
        return "<Lindef #:%s offs:0x%x>" % (self.linnum, self.linoff)


class Linnum(Record):
    def unpack(self):
        fmt = "<HH"
        ofs = 0
        self.fi, self.linbase = struct.unpack_from(fmt, self.data, ofs)
        ofs += struct.calcsize(fmt)
        self.recs = []
        while ofs < len(self.data):
            fmt = "<HBI"
            linnum, _, linoff = struct.unpack_from(fmt, self.data, ofs)
            ofs += struct.calcsize(fmt)
            if linnum == 0xffff:
                fmt = "<I"
                linnum = struct.unpack_from(fmt, self.data, ofs)[0]
                ofs += struct.calcsize(fmt)
            self.recs.append(LinDef(linnum, linoff))

    def __str__(self):
        return "<Linnum fi:%s linbase:%s recs: %s>" % (self.fi, self.linbase, ", ".join(map(str, self.recs)))


#
# Sub-record of Filedef
#
class Filerec(Record):
    def __init__(self, fi, mode, filename, pathname, time32):
        self.fi = fi
        self.mode = mode
        self.filename = filename
        self.pathname = pathname
        self.time32 = time32

    def __str__(self):
        return "<File %s %s %s %s %s>" % (self.filename, self.pathname, self.fi, self.mode, self.time32)


class Filedef(Record):
    def unpack(self):
        self.files = []
        ofs = 0
        while ofs < len(self.data):
            fmt = "<HBB"
            fi, mode, strlen = struct.unpack_from(fmt, self.data, ofs)
            ofs += struct.calcsize(fmt)
            fmt = "<%ssB" % strlen
            filename, strlen = struct.unpack_from(fmt, self.data, ofs)
            ofs += struct.calcsize(fmt)
            fmt = "<%ssI" % strlen
            pathname, time32 = struct.unpack_from(fmt, self.data, ofs)
            ofs += struct.calcsize(fmt)
            self.files.append(Filerec(fi, mode, filename, pathname, time32))

    def __str__(self):
        return "<File %s files [%s]>" % (len(self.files), ", ".join(map(str, self.files)))


class Content(Record):
    def unpack(self):
        fmt = "<HHBBI"
        fields = struct.unpack_from(fmt, self.data, 0)
        self.fi = fields[0]
        self.base = fields[1]
        self.flags = fields[2]
        self.offset = fields[4]
        self.contentData = map(ord, self.data[struct.calcsize(fmt):])

    def __str__(self):
        return "<Content FI:%s Base:%s Flags:%s Offset:%s>" % (self.fi, self.base, self.flags, hex(self.offset))


#
# Type definition record.
#

class Typdef(Record):
    pass


class Function(Typdef):
    def unpack(self):
        fmt = "<BBIBIBIIHHH"
        fields = struct.unpack(fmt, self.data)
        self.venid = fields[1]
        self.framesize = fields[4]
        self.stacksize = fields[6]
        self.mci = fields[8]
        self.returnti = fields[9]
        self.parmlistti = fields[10]

    def __str__(self):
        return "<Function venid=%s framsize=%s stacksize=%s mci=%s returnti=%s parmlistti=%s>" % \
            (self.venid, self.framesize, self.stacksize, showmci(self.mci), showti(self.returnti), showti(self.parmlistti))


class Component(Typdef):
    def unpack(self):
        fmt = "<BBIHHHB"

        offset = 0
        fields = struct.unpack_from(fmt, self.data, offset)
        strlen = fields[6]
        offset += struct.calcsize(fmt)
        fmt = "%ss" % strlen
        name = struct.unpack_from(fmt, self.data, offset)[0]
        offset += struct.calcsize(fmt)

        self.offs = fields[2]
        self.mci = fields[3]
        self.ti = fields[4]
        self.name = name

    def __str__(self):
        return "<Component name=%s mci=%s ti=%s>" % (self.name, showmci(self.mci), showti(self.ti))


class ComponentList(Typdef):
    def unpack(self):
        fmt = "<BH"
        _, self.nrofcomp = struct.unpack_from(fmt, self.data, 0)
        offset = struct.calcsize(fmt)
        fmt = "%sH" % self.nrofcomp
        self.items = struct.unpack_from(fmt, self.data, offset)

    def __str__(self):
        return "<ComponentList %s, %s>" % (self.nrofcomp, str(self.items))


class Pointer(Typdef):
    def unpack(self):
        fmt = "<BBBHHHH"
        fields = struct.unpack(fmt, self.data)
        self.size = fields[1]
        self.venid = fields[2]
        self.attrib = fields[3]
        self.mci = fields[4]
        # self.reserved = fields[5]
        self.ti = fields[6]

    def __str__(self):
        return "<Pointer size:%s mci:%s ti:%s>" % (self.size, showmci(self.mci), showti(self.ti))


class Array(Typdef):
    def unpack(self):
        fmt = "<BBBH"
        fields = struct.unpack_from(fmt, self.data, 0)
        self.dims = fields[1]
        self.attrib = fields[2]
        self.ti = fields[3]
        ofs = struct.calcsize(fmt)
        fmt = "<%sI" % self.dims
        self.dimsz = struct.unpack_from(fmt, self.data, ofs)

    def __str__(self):
        return "<Array dims:%s attrib:%s ti:%s dimsz:%s>" % (self.dims, self.attrib, showti(self.ti), self.dimsz)


class Struct(Typdef):
    def unpack(self):
        fmt = "<BBIHB"
        _, self.attrib, self.size, self.ti, strlen = struct.unpack_from(fmt, self.data, 0)
        name = struct.unpack_from("%ss" % strlen, self.data, struct.calcsize(fmt))[0]
        self.name = name

    def __str__(self):
        return "<Struct %s size:%s attrib:%s ti:%s>" % (self.name, self.size, self.attrib, showti(self.ti))


class Bitfield(Typdef):
    def unpack(self):
        fmt = "<BHBB"
        _, self.ti, self.offset, self.width = struct.unpack(fmt, self.data)

    def __str__(self):
        return "<Bitfield ti:%s offset:%s width:%s>" % \
            (showti(self.ti), self.offset, self.width)

typsubtypes = {
    0x20: ("Component", Component),
    0x21: ("Component List", ComponentList),
    0x22: ("Pointer", Pointer),
    0x23: ("Array", Array),
    0x24: ("Function", Function),
    0x25: ("Struct", Struct),
    0x26: ("Bitfield", Bitfield),
    0x27: ("Typetag",),
}


def typdef(rectype, data):
    fmt = "<B"
    subtype = struct.unpack_from(fmt, data, 0)[0]
    subtypeinf = typsubtypes[subtype]
    if len(subtypeinf) > 1:
        t = subtypeinf[1](rectype, data)
    else:
        t = subtypeinf[0]
    return t

_rectypes = {
    0xc0: ("Translator Header", Theadr),
    0xc2: ("Linker Header (reloc)", Lheadr),
    0xc4: ("Linker Header (absolute)", Aheadr),
    0xc6: ("Module End", Modend),
    0xc8: ("Module Information", Modinf),
    0x80: ("Comment", Comment),
    0x82: ("Memory Classes",),
    0x84: ("Segment Definitions", Segdef),
    0x86: ("Static Overlay Definitions", Ovldef),
    0x87: ("Additional Procedure Information",),
    0x88: ("Public Symbol Definitions", Pubdef),
    0x8a: ("External Symbol Definitions",),
    0x8c: ("Local Debug Symbol Definitions", Debsym),
    0x8e: ("Block Start Definition", Blkdef),
    0x90: ("Block End Definition", Blkend),
    0x92: ("Source Line Numbers", Linnum),
    0x94: ("Code & Constant Content", Content),
    0x96: ("Fixup for Content",),
    0x98: ("Symbol Type Information", typdef),
    0x9a: ("Source File Information", Filedef),
    0xca: ("Startaddress",),
    0xcc: ("Local Symbol Information", Locsym),
    0xce: ("Stack adjust value for local symbols",),
    0xd0: ("Public SFT symbol definitions",),
    0x9c: ("Code Banking Definition Record",),
    0x9d: ("SLE66P MMU Definition Record",),
    0x9b: ("LEVEL_CALL Public Symbol",),
    0x9f: ("LEVEL_CALL External Symbol",),
    0xa0: ("LEVEL_CALL Fixup Record",),
    0xc1: ("Frame-Record",),
}


def _gen_checksum(data, pos, length):
    fmt = "<" + ("B" * length)
    vals = struct.unpack_from(fmt, data, pos)
    checksum = 256 - (sum(vals) % 256)
    if checksum == 256:
        checksum = 0
    return checksum


def _get_record(rectype, content):
    recinf = _rectypes.get(rectype, ("Unknown %x" % rectype,))
    if len(recinf) > 1:
        return recinf[1](rectype, content)
    else:
        pass


def parse(data):
    pos = 0
    while pos < len(data):
        fmt = "<BH"
        (rectype, reclen) = struct.unpack_from(fmt, data, pos)
        content = data[pos + 3:pos + 3 + reclen - 1]
        # Get the checksum byte
        checksum = struct.unpack_from("<B", data, pos + 3 + reclen - 1)[0]
        # Validate checksum
        if checksum != _gen_checksum(data, pos, reclen + 3 - 1):
            raise Exception("Format error, checksum failure")
        pos += (reclen + 3)
        yield _get_record(rectype, content)


#
# Part 2: High level parsing
#
def loadIntegerValue(databytes, signed=False):
    val = 0
    for byte in databytes:
        val <<= 8
        val += byte
    if signed and val >= (2 ** ((len(databytes) * 8) - 1)):
        val = -1 * ((2 ** (len(databytes) * 8)) - val)

    return val


integerFmts = {1: "b", 2: "h", 4: "i"}


def integerAsBytes(value, size=1, signed=False):
    if size not in integerFmts:
        raise ValueError("Can only handle value with sizes: %s" % integerFmts.keys())
    bits = (size * 8)
    if signed:
        maxVal = (2 ** (bits - 1)) - 1
        minVal = -(2 ** (bits - 1))
    else:
        minVal = 0
        maxVal = (2 ** bits) - 1

    if value < minVal or value > maxVal:
        raise ValueError("Value (%d) must be betweeen %d and %d" % (value, minVal, maxVal))

    fmt = integerFmts[size]
    if not signed:
        fmt = fmt.upper()

    return [ord(x) for x in struct.pack(">" + fmt, value)]


class IntegerType(object):
    def __init__(self, size, signed, name):
        self.size = size
        self.signed = signed
        self.name = name

    def loadValue(self, databytes):
        if len(databytes) != self.size:
            raise Exception("Incorrect size")
        return loadIntegerValue(databytes, self.signed)

    def valueAsBytes(self, value):
        return integerAsBytes(value, self.size, self.signed)

    def show(self, value):
        if self.signed:
            return " %d" % (value)
        else:
            return " %d    0x%x" % (value, value)

    def setup(self):
        pass


class FloatingType(object):
    def __init__(self, size, name):
        self.size = size
        self.name = name
        if self.size == 4:
            self.ctype = ctypes.c_float.__ctype_be__
        elif self.size == 8:
            self.ctype = ctypes.c_double.__ctype_be__
        else:
            raise ValueError("Size must be 4 or 8")

    def loadValue(self, databytes):
        if len(databytes) != self.size:
            raise Exception("Incorrect size")
        float_be = self.ctype()
        ctypes.memmove(ctypes.addressof(float_be), (ctypes.c_ubyte * self.size)(*databytes), self.size)
        return float_be.value

    def valueAsBytes(self, value):
        float_be = self.ctype(value)
        cbuffer = (ctypes.c_ubyte * self.size)()
        ctypes.memmove(ctypes.addressof(cbuffer), ctypes.addressof(float_be), self.size)
        return cbuffer[:]

    def show(self, value):
        return " %f" % (value)

    def setup(self):
        pass


class Void(object):
    name = "void"

    def setup(self):
        pass


signed_char = IntegerType(1, True, "signed char")
unsigned_char = IntegerType(1, False, "unsigned char")
signed_int = IntegerType(2, True, "signed int")
unsigned_int = IntegerType(2, False, "unsigned int")
signed_long = IntegerType(4, True, "signed long")
unsigned_long = IntegerType(4, False, "unsigned long")
float = FloatingType(4, "float")
double = FloatingType(8, "double")
void = Void()


class Type(object):
    def __init__(self, rec, omf2file):
        self.rec = rec
        if hasattr(rec, "size"):
            self.size = rec.size / 8
        else:
            self.size = 1
        self.name = str(rec)
        self.omf2file = omf2file

    def loadValue(self, databytes):
        return bytes

    def show(self, value):
        return "Don't know how to show this type (%s) - %s" % (self.rec, value)

    def setup(self):
        pass


class String(object):
    def __init__(self, rec, omf2file):
        self.special_string = True
        self.addressSize = rec.size / 8
        self.name = "string"
        self.omf2file = omf2file

    def getAddress(self, databytes):
        if len(databytes) != self.addressSize:
            raise Exception("Incorrect size")
        return loadIntegerValue(databytes)

    def loadValue(self, value):
        (address, databytes) = value
        returnstr = "".join([chr(s) for s in databytes])
        return (address, returnstr)

    def show(self, value):
        (address, string) = value
        return "0x%x [%s]" % (address, string)

    def setup(self):
        pass


class TypeArray(object):
    def __init__(self, rec, omf2file):
        self.name = "array"
        self.rec = rec
        self.omf2file = omf2file

    def setup(self):
        self.basictype = self.omf2file.typeindex[self.rec.ti]
        sz = self.basictype.size
        for each in self.rec.dimsz:
            sz *= each
        self.size = sz

    def valueAsBytes(self, value):
        if self.rec.dims > 1:
            raise Exception("Can't currently get value for arrays with dimension > 1")
        assert len(value) == self.rec.dimsz[0]
        databytes = []
        for v in value:
            databytes += self.omf2file.typeindex[self.rec.ti].valueAsBytes(v)
        return databytes

    def loadValue(self, databytes):
        # Note: This code is horrible and quick. Someone smarter should be able to
        # make this happen in a nice and generic way.
        if self.rec.dims > 2:
            raise Exception("Can't currently load arrays with dimension > 1")
        if self.rec.dims == 1:
            ret = []
            for i in range(self.rec.dimsz[0]):
                member_bytes = databytes[i * self.basictype.size:(i + 1) * self.basictype.size]
                member = self.omf2file.typeindex[self.rec.ti].loadValue(member_bytes)
                ret.append(member)
            return ret

        if self.rec.dims == 2:
            ret = []
            offset = 0
            for _ in range(self.rec.dimsz[0]):
                a = []
                for i in range(self.rec.dimsz[1]):
                    member_bytes = databytes[offset + i * self.basictype.size:offset + (i + 1) * self.basictype.size]
                    member = self.omf2file.typeindex[self.rec.ti].loadValue(member_bytes)
                    a.append(member)
                ret.append(a)
                offset += (i + 1) * self.basictype.size
            return ret


class TypePointer(object):
    def __init__(self, rec, omf2file):
        self.name = "pointer"
        self.rec = rec
        self.size = self.rec.size / 8
        self.omf2file = omf2file

    def setup(self):
        pass

    def loadValue(self, databytes):
        return loadIntegerValue(databytes)

    def valueAsBytes(self, value):
        return integerAsBytes(value, self.size, False)

    def show(self, value):
        return "(%d) Pointer to (%d) %s - 0x%06x" % (id(self), self.rec.ti, self.omf2file.typeindex[self.rec.ti].name, value)


class TypeStruct(object):
    def __init__(self, rec, omf2file):
        self.name = "struct %s" % rec.name
        self.rec = rec
        self.size = self.rec.size
        self.omf2file = omf2file

    def setup(self):
        # Work out what the fields are, and what types they are
        clist = self.omf2file.typeindex[self.rec.ti]
        self.fields = []
        clist.setup()
        for component in clist.components:
            self.fields.append(component)
        # Find the component list

    def loadValue(self, databytes):
        ret = []
        offset = 0
        for comp in self.fields:
            field_len = self.omf2file.typeindex[comp.rec.ti].size
            field_slice = databytes[offset:offset + field_len]
            offset += field_len
            ret.append(self.omf2file.typeindex[comp.rec.ti].loadValue(field_slice))
        return ret

    def valueAsBytes(self, value):
        databytes = []
        for (v, comp) in zip(value, self.fields):
            databytes += self.omf2file.typeindex[comp.rec.ti].valueAsBytes(v)
        return databytes

    def show(self, value):
        r = " { "
        r += "\n  ".join("%s (%s): %s" % (comp.name, comp.type.name, comp.type.show(value))
                         for comp, value in zip(self.fields, value))
        r += "}"
        return r


class TypeUnion(object):
    def __init__(self, rec, omf2file):
        self.name = "union %s" % rec.name
        self.rec = rec
        self.size = self.rec.size
        self.omf2file = omf2file

    def setup(self):
        # Work out what the fields are, and what types they are
        clist = self.omf2file.typeindex[self.rec.ti]
        self.fields = []
        clist.setup()
        for component in clist.components:
            self.fields.append(component)
        # Find the component list

    def loadValue(self, databytes):
        ret = {}
        for comp in self.fields:
            ret[comp.name] = self.omf2file.typeindex[comp.rec.ti].loadValue(databytes)
        return ret

    def show(self, value):
        r = " { "
        r += "\n  ".join("%s (%s): %s" % (comp.name, comp.type.name, comp.type.show(value))
                         for comp, value in zip(self.fields, value))
        r += "}"
        return r


class TypeComponentList(object):
    def __init__(self, rec, omf2file):
        self.rec = rec
        self.components = []
        self.omf2file = omf2file

    def setup(self):
        for comp in self.rec.items:
            self.components.append(self.omf2file.typeindex[comp])


class TypeComponent(object):
    def __init__(self, rec, omf2file):
        self.rec = rec
        self.name = rec.name
        self.omf2file = omf2file

    def setup(self):
        self.type = self.omf2file.typeindex[self.rec.ti]


class TypeFunction(object):
    def __init__(self, rec, omf2file):
        self.rec = rec
        self.omf2file = omf2file

    def setup(self):
        # print "Setting up function param list typeindex:", self.rec.parmlistti
        self.params = []
        if self.rec.parmlistti == 0:
            self.params = None
        else:
            self.params = self.omf2file.typeindex[self.rec.parmlistti]
        self.returntype = self.omf2file.typeindex[self.rec.returnti]

    def show(self):
        if self.params is None:
            return "%s (void)" % (self.returntype.name)
        else:
            return "%s (%s)" % (self.returntype.name, ", ".join(["%s : %s" % (x.name, x.type.name) for x in self.params.components]))


def typeLoader(omf2file, rec):
    if isinstance(rec, Array):
        return TypeArray(rec, omf2file)
    if isinstance(rec, Struct) and rec.attrib == 1:
        return TypeStruct(rec, omf2file)
    if isinstance(rec, Struct) and rec.attrib == 2:
        return TypeUnion(rec, omf2file)
    if isinstance(rec, Pointer):
        return TypePointer(rec, omf2file)
    if isinstance(rec, Function):
        return TypeFunction(rec, omf2file)
    if isinstance(rec, ComponentList):
        return TypeComponentList(rec, omf2file)
    if isinstance(rec, Component):
        return TypeComponent(rec, omf2file)
    return Type(rec, omf2file)


class Symbol(object):
    """
    This class represents an OMF2 symbol. Currently
    it has the following instance variables:

    name: The symbol name.
    address: The address that the symbol refers to.
    module: The name of the module in which this is symbol is defined.
    debug: True if this is a debug (private) symbol.
    """

    def __init__(self, name, address, module, ctype, ctype_id, debug=False):
        self.name = name
        self.address = address
        self.module = module
        self.debug = debug
        self.ctype = ctype
        self.ctype_id = ctype_id
        self.value = None

    def __str__(self):
        if self.debug:
            name = "%s.%s" % (self.module, self.name)
        else:
            name = self.name
        return "<Symbol %s address: 0x%x>" % (name, self.address)

    def loadValue(self, databytes):
        self.value = self.ctype.loadValue(databytes)

    def show(self):
        return "<%s-%d> %s" % (id(self.ctype), self.ctype_id, self.ctype.show(self.value))


class Block(object):
    """This class represents an OMF2 block. It may be nested."""
    def __init__(self, rec, parent=None, module=None):
        self.rec = rec
        self.contents = []
        self.parent = parent
        self.module = module
        self.size = None

    def _setsize(self):
        s = 0
        for each in self.contents:
            if isinstance(each, Block):
                s += each.size
            else:
                s += len(each.contentData)
        self.size = s

    def push(self, rec):
        newBlock = Block(rec, self, self.module)
        self.contents.append(newBlock)
        return newBlock

    def pop(self, rec):
        self.endrec = rec
        self._setsize()
        return self.parent

    def addContent(self, rec):
        self.contents.append(rec)

    def __str__(self):
        return "<Block %s>" % self.rec.name


class Omf2File(object):
    """
    The Omf2File class is used to provide easy access to
    the data contained in an OMF2 formatted object file.

    The Omf2File instances are read-only; there is no
    way to manipulate the Omf2File data, and no way to generate
    OMF2 formatted files.


    @ivar symbols: The symbols instance variable is a dictionary of Symbol instances.
    The dictionary includes both public and private/debug symbols.

    Symbols are named:
     - <varname> for public symbols
     - <module>.<varname> for debug/private symbols

    This naming is used to ensure that we have a unique set of
    symbol names. Multiple C modules could define the same variable
    name locally.
    """
    def __init__(self, filename):
        """
        Omf2File constructor

        Thie filename to parse and load.
        """
        self.filename = filename
        data = open(filename, "rb").read()

        self.symbols = {}
        self.segments = []
        self.segmentDict = {}
        self.contents = []
        self.unattached_contents = []
        self.blocks = []
        self.files = {}
        self.linedefs = {}
        curmodule = None

        typecounter = 0x80

        self.typeindex = {0x2: signed_char,
                          0x3: unsigned_char,
                          0x4: signed_int,
                          0x5: unsigned_int,
                          0x6: signed_long,
                          0x7: unsigned_long,
                          0xb: void,
                          0xc: float,
                          0xd: double
                          }

        self.arguments = {}

        curblk = None

        for rec in parse(data):
#            print rec
            if isinstance(rec, Typdef):
                self.typeindex[typecounter] = typeLoader(self, rec)
                typecounter += 1
            if rec.__class__ in (Pubdef, Debsym):
                for subrec in rec.records:
                    if rec.__class__ == Debsym:
                        name = "%s.%s" % (curmodule.name, subrec.name)
                    else:
                        name = subrec.name
                    if subrec.base != 0:
                        raise Exception("Can't currently handle non-absolute addresses")
                    ctype = self.typeindex.get(subrec.ti, None)
                    s = Symbol(subrec.name, subrec.offs, curmodule.name, ctype, subrec.ti, rec.__class__ == Debsym)
                    if curblk is not None:
                        index = ((curblk.module.name, curblk.rec.name))
                        if index not in self.arguments:
                            self.arguments[index] = []
                        ctype = self.typeindex.get(subrec.ti, None)
                        self.arguments[index].append(subrec.name + "@" + hex(subrec.offs))
                    else:
                        self.symbols[name] = s
            if rec.__class__ == Locsym:
                # Locsym can hold function names and types
                if curblk is not None:
                    index = ((curblk.module.name, curblk.rec.name))
                    if index not in self.arguments:
                        self.arguments[index] = []
                    ctype = self.typeindex.get(rec.ti, None)
                    self.arguments[index].append(rec.name)
            if rec.__class__ in (Theadr, Lheadr):
                curmodule = rec

            if rec.__class__ in (Segdef,):
                self.segments.append(rec)
                self.segmentDict[rec.name] = rec

            if rec.__class__ == Blkdef:
                if curblk is None:
                    curblk = Block(rec, module=curmodule)
                    self.blocks.append(curblk)
                else:
                    curblk = curblk.push(rec)

            if rec.__class__ == Blkend:
                curblk = curblk.pop(rec)

            if rec.__class__ in (Content,):
                self.contents.append(rec)
                if curblk is not None:
                    curblk.addContent(rec)
                else:
                    self.unattached_contents.append(rec)

            if rec.__class__ in (Filedef,):
                for f in rec.files:
                    self.files[f.fi] = f

            if rec.__class__ in (Linnum,):
                f = self.files[rec.fi]
                for o in rec.recs:
                    o.file = f
                    self.linedefs[o.linoff] = o

        for x in self.typeindex.values():
            x.setup()

    def getBaseAddr(self, baseIdx):
        """Determine the base address for a given 'base' index.

        A number of different records have a 'base' entry which is used
        to generate a base address from which offsets are relative to.

        If baseIdx is zero, then the offset is an absolute address.

        Otherwise the baseIdx indexs a segment, and the baseAddress is
        the segment's address.
        """
        if baseIdx == 0:
            return 0
        else:
            return self.segments[baseIdx - 1].addr

    def getRegions(self):
        """Return the regions used by this OMF2 file."""
        segments = sorted([(seg.addr, seg.addr + seg.seglen) for seg in self.segments])
        mergedSegments = [segments[0]]
        for segment in segments[1:]:
            if segment[0] == mergedSegments[-1][1]:
                mergedSegments[-1] = (mergedSegments[-1][0], segment[1])
            else:
                mergedSegments.append(segment)
        segments = [(base, end - base) for base, end in mergedSegments]
        return segments

    def getData(self):
        """Return a list tuples: [(base address, data)]

        data is represented as a list of integers (0 - 255).
        """
        initedata = self.segmentDict.get("?C_INITEDATA")

        extractBase = None
        extractLen = None
        edataBlocks = []
        if initedata and initedata.addr == 0xf00000:
            extractBase = 0xf00000
            extractLen = initedata.seglen

            edata = sorted([(seg.addr, seg.addr + seg.seglen) for seg in self.segments if memindex.get(seg.mci) == 'EDATA'])
            edata.append((None, None))  # Add a sentinel value
            startOfBlock = 0
            for i in range(len(edata) - 1):
                if edata[i][1] != edata[i + 1][0]:

                    edataLen = (edata[i][1] - edata[startOfBlock][0])
                    edataBlock = [0] * edataLen
                    edataBase = edata[startOfBlock][0]
                    edataBlocks.append((edataBase, edataBlock))
                    startOfBlock = i + 1

        ordered = [(self.getBaseAddr(c.base) + c.offset, c) for c in self.contents]
        ordered.sort()
        data = []
        startAddr = ordered[0][0]
        lastAddr = startAddr
        blocks = []
        for addr, c in ordered:
            if addr > lastAddr:
                blocks.append((startAddr, data))
                data = []
                startAddr = addr

            data += c.contentData
            lastAddr = addr + len(c.contentData)
        blocks.append((startAddr, data))
        if extractBase:
            for block in blocks:
                if block[0] == extractBase:
                    break
            else:
                raise Exception("Couldn't find expected INITEDATA stuff")
            if len(block[1]) != extractLen:
                raise Exception("Unexepcetd elntgh: (%d != %d)" % (len(block[1]), extractLen))

            blocks.remove(block)

            data = block[1]
            offset = 0

            while offset < len(data):
                length = data[offset + 0] << 8 | data[offset + 1]
                addr = data[offset + 2] << 8 | data[offset + 3]
                content = data[offset + 4:offset + 4 + length]

                for edataBlock in edataBlocks:
                    if addr >= edataBlock[0] and addr + length <= edataBlock[0] + len(edataBlock[1]):
                        break
                else:
                    raise Exception("Can't find EDATA for initializer addr: %x length: %d" % (addr, length))

                blockOffs = addr - edataBlock[0]
                edataBlock[1][blockOffs:blockOffs + length] = content

                offset = offset + 4 + length

            blocks += edataBlocks[:]

        blocks.sort()
        mergedBlocks = [blocks[0]]
        for block in blocks[1:]:
            if block[0] == mergedBlocks[-1][0] + len(mergedBlocks[-1][1]):
                # Merge
                mergedBlocks[-1] = (mergedBlocks[-1][0], mergedBlocks[-1][1] + block[1])
            else:
                mergedBlocks.append(block)
        blocks = mergedBlocks

        return blocks

if __name__ == "__main__":
    a = Omf2File("romComLayer.abs")
    b = a.getData()
    print a
